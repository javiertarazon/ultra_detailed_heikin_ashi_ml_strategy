#!/usr/bin/env python3
"""
Auditor√≠a de Datos Live desde Exchange Testnet
==============================================

Este script realiza una auditor√≠a completa de los datos obtenidos en tiempo real
desde el testnet del exchange configurado (Binance o Bybit), verificando calidad,
consistencia y rendimiento.

Funcionalidades:
1. Conexi√≥n al exchange de testnet usando CCXT
2. Validaci√≥n de calidad de datos (precios, vol√∫menes, timestamps)
3. Pruebas de latencia y frecuencia de actualizaci√≥n
4. An√°lisis de consistencia de datos hist√≥ricos vs tiempo real
5. Auditor√≠a de operaciones de trading (compra, venta, trailing stops)
6. Generaci√≥n de reporte detallado con m√©tricas

Uso:
python auditorias/audit_binance_testnet_data.py

Requisitos:
- Credenciales del exchange configurado en .env
- CCXT instalado
- Conexi√≥n a internet

Author: GitHub Copilot
Date: Octubre 2025
"""

import os
import sys
import time
import asyncio
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import json
import logging
from dataclasses import dataclass
from concurrent.futures import ThreadPoolExecutor

# Agregar directorio ra√≠z al path
sys.path.insert(0, str(Path(__file__).resolve().parent.parent))

# Importar sistema de logging centralizado
from utils.logger import initialize_system_logging, get_logger

# Inicializar logging
initialize_system_logging({
    'level': 'INFO',
    'file': 'logs/binance_testnet_audit.log'
})

logger = get_logger('binance_testnet_audit')

# Cargar variables de entorno desde .env
try:
    from dotenv import load_dotenv
    dotenv_path = Path(__file__).parent.parent / '.env'
    success = load_dotenv(dotenv_path=dotenv_path)
    if success:
        logger.info(f"‚úÖ Variables de entorno cargadas desde {dotenv_path}")
    else:
        logger.warning(f"‚ö†Ô∏è No se pudieron cargar variables desde {dotenv_path}")
        # Intentar sin path espec√≠fico
        load_dotenv()
        logger.info("‚ÑπÔ∏è Intentando carga autom√°tica de .env")
except ImportError:
    logger.warning("‚ö†Ô∏è python-dotenv no disponible, usando variables de entorno del sistema")

# Detectar exchange activo
ACTIVE_EXCHANGE = os.getenv('ACTIVE_EXCHANGE', 'binance').lower()
logger.info(f"üîÑ Exchange activo detectado: {ACTIVE_EXCHANGE}")

# Intentar importar CCXT
try:
    import ccxt
    import ccxt.async_support as ccxt_async
    CCXT_AVAILABLE = True
except ImportError:
    CCXT_AVAILABLE = False
    logger.error("CCXT no disponible - Se requiere para auditor√≠a de Binance")

@dataclass
class AuditMetrics:
    """M√©tricas recopiladas durante la auditor√≠a"""
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    avg_latency_ms: float = 0.0
    min_latency_ms: float = float('inf')
    max_latency_ms: float = 0.0
    data_quality_score: float = 0.0
    timestamp_consistency: bool = True
    price_anomalies: int = 0
    volume_anomalies: int = 0
    connection_drops: int = 0
    start_time: datetime = None
    end_time: datetime = None

    def __post_init__(self):
        if self.start_time is None:
            self.start_time = datetime.now()

class ExchangeTestnetAuditor:
    """
    Auditor de datos live desde Exchange Testnet.

    Realiza pruebas exhaustivas de calidad y rendimiento de datos.
    """

    def __init__(self, config_path: str = None):
        """
        Inicializa el auditor de Exchange Testnet.

        Args:
            config_path: Ruta al archivo de configuraci√≥n (opcional)
        """
        self.config_path = config_path
        self.exchange = None
        self.metrics = AuditMetrics()
        self.test_symbols = ['BTC/USDT', 'ETH/USDT', 'BNB/USDT']
        self.test_timeframes = ['1m', '5m', '15m']
        self.audit_duration_minutes = 5  # Duraci√≥n de la auditor√≠a en minutos
        self.sample_interval_seconds = 10  # Intervalo entre muestras
        self.public_mode = False  # Modo p√∫blico sin credenciales

        # Cargar configuraci√≥n si existe
        self.config = {}
        if self.config_path and Path(self.config_path).exists():
            self._load_config()

        # Inicializar exchange
        self._init_exchange()

    def _load_config(self):
        """Carga la configuraci√≥n desde archivo YAML"""
        try:
            import yaml
            with open(self.config_path, 'r', encoding='utf-8') as f:
                self.config = yaml.safe_load(f)
            logger.info(f"‚úÖ Configuraci√≥n cargada desde {self.config_path}")
        except Exception as e:
            logger.error(f"‚ùå Error cargando configuraci√≥n: {e}")
            self.config = {}

    def _init_exchange(self):
        """Inicializa la conexi√≥n a Exchange Testnet"""
        if not CCXT_AVAILABLE:
            raise RuntimeError("CCXT no est√° disponible")

        try:
            # Obtener exchange activo desde .env
            active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').lower()

            # Obtener credenciales seg√∫n el exchange
            if active_exchange == 'binance':
                api_key = os.getenv('BINANCE_API_KEY')
                api_secret = os.getenv('BINANCE_API_SECRET')
                exchange_class = ccxt.binance
                exchange_name = "Binance"
            elif active_exchange == 'bybit':
                api_key = os.getenv('BYBIT_API_KEY')
                api_secret = os.getenv('BYBIT_API_SECRET')
                exchange_class = ccxt.bybit
                exchange_name = "Bybit"
            else:
                raise ValueError(f"Exchange no soportado: {active_exchange}")

            logger.info(f"DEBUG: API_KEY presente: {bool(api_key)}, API_SECRET presente: {bool(api_secret)}")
            # Si no hay credenciales, usar modo p√∫blico limitado
            if not api_key or not api_secret:
                logger.warning(f"‚ö†Ô∏è Credenciales no configuradas para {exchange_name} - Usando modo auditor√≠a p√∫blica limitada")
                self.exchange = exchange_class({
                    'sandbox': True,
                    'enableRateLimit': True,
                    'options': {
                        'defaultType': 'spot',
                    }
                })
                self.public_mode = True
            else:
                # Modo completo con credenciales
                self.exchange = exchange_class({
                    'apiKey': api_key,
                    'secret': api_secret,
                    'sandbox': True,
                    'test': True,
                    'enableRateLimit': True,
                    'options': {
                        'defaultType': 'spot',
                    }
                })
                self.public_mode = False

            logger.info(f"‚úÖ Exchange {exchange_name} Testnet inicializado" + (" (modo p√∫blico)" if self.public_mode else ""))

        except Exception as e:
            logger.error(f"‚ùå Error inicializando exchange: {e}")
            raise

    def test_connection(self) -> bool:
        """Prueba la conexi√≥n b√°sica al exchange"""
        try:
            active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
            logger.info(f"üîç Probando conexi√≥n a {active_exchange} Testnet...")

            # Probar conexi√≥n - cargar mercados (disponible en modo p√∫blico)
            self.exchange.loadMarkets()
            logger.info("‚úÖ Mercados cargados exitosamente")

            # En modo p√∫blico, no podemos obtener balance
            if not self.public_mode:
                # Obtener balance solo si tenemos credenciales
                balance = self.exchange.fetchBalance()
                free_balance = balance.get('free', {})
                usdt_balance = free_balance.get('USDT', 0)
                btc_balance = free_balance.get('BTC', 0)
                logger.info(f"‚úÖ Conexi√≥n completa. Balance disponible: USDT={usdt_balance}, BTC={btc_balance}")
                logger.info(f"üìä Balance completo: {free_balance}")
            else:
                logger.info("‚úÖ Conexi√≥n en modo p√∫blico (sin credenciales)")

            return True

        except Exception as e:
            logger.error(f"‚ùå Error de conexi√≥n: {e}")
            return False

    def audit_data_quality(self, symbol: str, timeframe: str) -> Dict:
        """
        Audita la calidad de datos para un s√≠mbolo y timeframe espec√≠fico.

        Args:
            symbol: S√≠mbolo a auditar (ej: 'BTC/USDT')
            timeframe: Timeframe (ej: '1m', '5m')

        Returns:
            Dict con m√©tricas de calidad
        """
        logger.info(f"üîç Auditando calidad de datos: {symbol} {timeframe}")

        quality_metrics = {
            'symbol': symbol,
            'timeframe': timeframe,
            'samples_collected': 0,
            'price_anomalies': 0,
            'volume_anomalies': 0,
            'timestamp_issues': 0,
            'avg_price': 0.0,
            'avg_volume': 0.0,
            'price_volatility': 0.0,
            'data_completeness': 0.0
        }

        try:
            # Obtener datos hist√≥ricos recientes
            since = self.exchange.parse8601((datetime.now() - timedelta(hours=1)).isoformat())
            ohlcv = self.exchange.fetchOHLCV(symbol, timeframe, since=since, limit=100)

            if not ohlcv:
                logger.warning(f"‚ö†Ô∏è No se obtuvieron datos para {symbol} {timeframe}")
                return quality_metrics

            # Convertir a DataFrame para an√°lisis
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

            quality_metrics['samples_collected'] = len(df)

            if len(df) > 1:
                # Calcular m√©tricas de calidad
                quality_metrics['avg_price'] = df['close'].mean()
                quality_metrics['avg_volume'] = df['volume'].mean()
                quality_metrics['price_volatility'] = df['close'].std() / df['close'].mean()

                # Verificar anomal√≠as de precio
                price_changes = df['close'].pct_change().abs()
                quality_metrics['price_anomalies'] = (price_changes > 0.1).sum()  # Cambios > 10%

                # Verificar anomal√≠as de volumen
                volume_mean = df['volume'].mean()
                volume_std = df['volume'].std()
                quality_metrics['volume_anomalies'] = ((df['volume'] - volume_mean).abs() > 3 * volume_std).sum()

                # Verificar timestamps
                expected_interval = pd.Timedelta(timeframe)
                timestamp_diffs = df['timestamp'].diff()
                quality_metrics['timestamp_issues'] = (timestamp_diffs != expected_interval).sum()

                # Calcular completitud de datos
                total_expected = len(df)
                quality_metrics['data_completeness'] = (total_expected - quality_metrics['timestamp_issues']) / total_expected

            logger.info(f"‚úÖ An√°lisis completado para {symbol} {timeframe}: {quality_metrics['samples_collected']} muestras")

        except Exception as e:
            logger.error(f"‚ùå Error auditando {symbol} {timeframe}: {e}")

        return quality_metrics

    def audit_latency(self, symbol: str, num_tests: int = 10) -> Dict:
        """
        Mide la latencia de las llamadas a la API.

        Args:
            symbol: S√≠mbolo para las pruebas
            num_tests: N√∫mero de pruebas a realizar

        Returns:
            Dict con m√©tricas de latencia
        """
        logger.info(f"‚è±Ô∏è Midiendo latencia para {symbol} ({num_tests} pruebas)")

        latencies = []
        successful_requests = 0

        for i in range(num_tests):
            try:
                start_time = time.time()

                # Hacer una llamada simple
                ticker = self.exchange.fetchTicker(symbol)

                end_time = time.time()
                latency_ms = (end_time - start_time) * 1000

                latencies.append(latency_ms)
                successful_requests += 1

                logger.debug(f"Prueba {i+1}: {latency_ms:.2f}ms")

                # Peque√±a pausa entre pruebas
                time.sleep(0.1)

            except Exception as e:
                logger.warning(f"Prueba {i+1} fallida: {e}")

        latency_metrics = {
            'symbol': symbol,
            'total_tests': num_tests,
            'successful_tests': successful_requests,
            'success_rate': successful_requests / num_tests,
            'avg_latency_ms': np.mean(latencies) if latencies else 0,
            'min_latency_ms': min(latencies) if latencies else 0,
            'max_latency_ms': max(latencies) if latencies else 0,
            'p95_latency_ms': np.percentile(latencies, 95) if latencies else 0
        }

        logger.info(f"‚úÖ Latencia medida: {latency_metrics['avg_latency_ms']:.2f}ms promedio")

        return latency_metrics

    def audit_trading_operations(self) -> Dict:
        """
        Audita operaciones de trading: √≥rdenes de compra/venta, stop loss, take profit, etc.

        Returns:
            Dict con resultados de las pruebas de trading
        """
        logger.info("üîÑ Iniciando auditor√≠a de operaciones de trading")

        trading_results = {
            'balance_check': {},
            'market_buy_order': {},
            'market_sell_order': {},
            'limit_buy_order': {},
            'limit_sell_order': {},
            'stop_loss_order': {},
            'take_profit_order': {},
            'oco_order': {},
            'order_cancellation': {},
            'position_management': {},
            'overall_trading_score': 0.0
        }

        test_symbol = 'BTC/USDT'
        test_amount = 0.001  # Cantidad peque√±a para pruebas

        try:
            # 1. Verificar balance
            logger.info("üí∞ Verificando balance de cuenta")
            balance = self.exchange.fetchBalance()
            usdt_balance = balance.get('USDT', {}).get('free', 0)
            btc_balance = balance.get('BTC', {}).get('free', 0)

            logger.info(f"üìä Balance detallado - USDT: {usdt_balance}, BTC: {btc_balance}")
            logger.info(f"üíº Balance completo: {balance}")

            trading_results['balance_check'] = {
                'usdt_free': usdt_balance,
                'btc_free': btc_balance,
                'status': 'SUCCESS' if usdt_balance > 0 else 'LOW_BALANCE'
            }

            if usdt_balance < 10:  # Necesitamos al menos algo de USDT
                logger.warning("‚ö†Ô∏è Balance USDT bajo - algunas pruebas pueden fallar")
                trading_results['balance_check']['warning'] = 'Low USDT balance for comprehensive testing'

            # 2. Probar orden de compra de mercado
            logger.info("üõí Probando orden de compra de mercado")
            try:
                # Obtener precio actual
                ticker = self.exchange.fetchTicker(test_symbol)
                current_price = ticker['last']

                # Calcular cantidad basada en balance disponible
                amount = min(test_amount, usdt_balance / current_price * 0.1)  # Usar solo 10% del balance

                if amount > 0.0001:  # M√≠nimo para BTC
                    buy_order = self.exchange.createMarketBuyOrder(test_symbol, amount)
                    trading_results['market_buy_order'] = {
                        'status': 'SUCCESS',
                        'order_id': buy_order['id'],
                        'amount': amount,
                        'price': current_price
                    }
                    logger.info(f"‚úÖ Orden de compra creada: {buy_order['id']}")
                else:
                    trading_results['market_buy_order'] = {
                        'status': 'SKIPPED',
                        'reason': 'Insufficient balance or amount too small'
                    }

            except Exception as e:
                trading_results['market_buy_order'] = {
                    'status': 'FAILED',
                    'error': str(e)
                }
                logger.error(f"‚ùå Error en orden de compra: {e}")

            # 3. Probar orden de venta de mercado (si tenemos BTC)
            logger.info("üí∏ Probando orden de venta de mercado")
            try:
                if btc_balance > 0.0001:
                    sell_amount = min(test_amount, btc_balance * 0.1)  # Vender solo 10%
                    sell_order = self.exchange.createMarketSellOrder(test_symbol, sell_amount)
                    trading_results['market_sell_order'] = {
                        'status': 'SUCCESS',
                        'order_id': sell_order['id'],
                        'amount': sell_amount
                    }
                    logger.info(f"‚úÖ Orden de venta creada: {sell_order['id']}")
                else:
                    trading_results['market_sell_order'] = {
                        'status': 'SKIPPED',
                        'reason': 'No BTC balance available'
                    }

            except Exception as e:
                trading_results['market_sell_order'] = {
                    'status': 'FAILED',
                    'error': str(e)
                }
                logger.error(f"‚ùå Error en orden de venta: {e}")

            # 4. Probar √≥rdenes limitadas
            logger.info("üìà Probando √≥rdenes limitadas")
            try:
                ticker = self.exchange.fetchTicker(test_symbol)
                current_price = ticker['last']

                # Orden limit buy por debajo del precio actual
                limit_buy_price = current_price * 0.995  # 0.5% por debajo
                limit_buy_amount = min(test_amount, usdt_balance / limit_buy_price * 0.05)

                if limit_buy_amount > 0.0001:
                    limit_buy = self.exchange.createLimitBuyOrder(test_symbol, limit_buy_amount, limit_buy_price)
                    trading_results['limit_buy_order'] = {
                        'status': 'SUCCESS',
                        'order_id': limit_buy['id'],
                        'price': limit_buy_price,
                        'amount': limit_buy_amount
                    }

                    # Cancelar la orden para no dejar posiciones abiertas
                    self.exchange.cancelOrder(limit_buy['id'], test_symbol)
                    trading_results['order_cancellation'] = {
                        'status': 'SUCCESS',
                        'cancelled_order': limit_buy['id']
                    }

                else:
                    trading_results['limit_buy_order'] = {'status': 'SKIPPED', 'reason': 'Insufficient balance'}

            except Exception as e:
                trading_results['limit_buy_order'] = {'status': 'FAILED', 'error': str(e)}
                logger.error(f"‚ùå Error en orden limit: {e}")

            # 5. Probar √≥rdenes OCO (One-Cancels-Other) para stop loss y take profit
            logger.info("üéØ Probando √≥rdenes OCO (Stop Loss + Take Profit)")
            try:
                if btc_balance > 0.0001:
                    ticker = self.exchange.fetchTicker(test_symbol)
                    current_price = ticker['last']

                    # Configurar OCO: Stop Loss 2% por debajo, Take Profit 3% por encima
                    stop_price = current_price * 0.98
                    limit_price = current_price * 1.03
                    oco_amount = min(test_amount, btc_balance * 0.05)

                    oco_order = self.exchange.createOrder(test_symbol, 'OCO', 'sell', oco_amount, None, {
                        'stopPrice': stop_price,
                        'stopLimitPrice': stop_price * 0.999,  # L√≠mite ligeramente por debajo del stop
                        'price': limit_price
                    })

                    trading_results['oco_order'] = {
                        'status': 'SUCCESS',
                        'order_id': oco_order['id'],
                        'stop_price': stop_price,
                        'take_profit_price': limit_price,
                        'amount': oco_amount
                    }

                    # Cancelar para limpiar
                    self.exchange.cancelOrder(oco_order['id'], test_symbol)

                else:
                    trading_results['oco_order'] = {'status': 'SKIPPED', 'reason': 'No BTC balance'}

            except Exception as e:
                trading_results['oco_order'] = {'status': 'FAILED', 'error': str(e)}
                logger.error(f"‚ùå Error en orden OCO: {e}")

            # 6. Calcular puntuaci√≥n general de trading
            successful_operations = sum(1 for op in trading_results.values()
                                      if isinstance(op, dict) and op.get('status') == 'SUCCESS')
            total_operations = len([op for op in trading_results.values() if isinstance(op, dict)])

            trading_results['overall_trading_score'] = (successful_operations / total_operations) * 100 if total_operations > 0 else 0

            logger.info(f"‚úÖ Auditor√≠a de trading completada. Puntuaci√≥n: {trading_results['overall_trading_score']:.1f}%")

        except Exception as e:
            logger.error(f"‚ùå Error general en auditor√≠a de trading: {e}")
            trading_results['error'] = str(e)

        return trading_results

    def run_comprehensive_audit(self) -> Dict:
        """
        Ejecuta una auditor√≠a completa del sistema.

        Returns:
            Dict con resultados completos de la auditor√≠a
        """
        active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
        logger.info(f"üöÄ Iniciando auditor√≠a completa de {active_exchange} Testnet")
        self.metrics.start_time = datetime.now()

        audit_results = {
            'audit_info': {
                'start_time': self.metrics.start_time.isoformat(),
                'testnet': True,
                'public_mode': self.public_mode,
                'symbols_tested': self.test_symbols,
                'timeframes_tested': self.test_timeframes,
                'duration_minutes': self.audit_duration_minutes
            },
            'connection_test': {},
            'data_quality': {},
            'latency_tests': {},
            'overall_metrics': {},
            'recommendations': []
        }

        try:
            # 1. Probar conexi√≥n
            logger.info("=== PRUEBA DE CONEXI√ìN ===")
            connection_ok = self.test_connection()
            audit_results['connection_test'] = {
                'status': 'SUCCESS' if connection_ok else 'FAILED',
                'timestamp': datetime.now().isoformat()
            }

            if not connection_ok:
                active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
                audit_results['recommendations'].append(f"‚ùå Verificar credenciales de {active_exchange} Testnet")
                audit_results['recommendations'].append("‚ùå Verificar conexi√≥n a internet")
                return audit_results

            # 2. Auditar calidad de datos
            logger.info("=== AUDITOR√çA DE CALIDAD DE DATOS ===")
            data_quality_results = {}

            for symbol in self.test_symbols:
                for timeframe in self.test_timeframes:
                    key = f"{symbol}_{timeframe}"
                    quality = self.audit_data_quality(symbol, timeframe)
                    data_quality_results[key] = quality

                    # Actualizar m√©tricas globales
                    self.metrics.price_anomalies += quality['price_anomalies']
                    self.metrics.volume_anomalies += quality['volume_anomalies']

            audit_results['data_quality'] = data_quality_results

            # 3. Probar latencia
            logger.info("=== PRUEBAS DE LATENCIA ===")
            latency_results = {}

            for symbol in self.test_symbols:
                latency = self.audit_latency(symbol, num_tests=5)
                latency_results[symbol] = latency

                # Actualizar m√©tricas globales
                self.metrics.avg_latency_ms = latency['avg_latency_ms']
                self.metrics.min_latency_ms = min(self.metrics.min_latency_ms, latency['min_latency_ms'])
                self.metrics.max_latency_ms = max(self.metrics.max_latency_ms, latency['max_latency_ms'])

            audit_results['latency_tests'] = latency_results

            # 4. Auditar operaciones de trading (solo si hay credenciales)
            if not self.public_mode:
                logger.info("=== AUDITOR√çA DE OPERACIONES DE TRADING ===")
                trading_results = self.audit_trading_operations()
                audit_results['trading_operations'] = trading_results
            else:
                audit_results['trading_operations'] = {
                    'status': 'SKIPPED',
                    'reason': 'Modo p√∫blico - sin credenciales para operaciones'
                }

            # 5. Generar m√©tricas generales
            self.metrics.end_time = datetime.now()
            audit_results['overall_metrics'] = {
                'total_duration_seconds': (self.metrics.end_time - self.metrics.start_time).total_seconds(),
                'avg_latency_ms': self.metrics.avg_latency_ms,
                'price_anomalies_detected': self.metrics.price_anomalies,
                'volume_anomalies_detected': self.metrics.volume_anomalies,
                'data_quality_score': self._calculate_data_quality_score(data_quality_results)
            }

            # 5. Generar recomendaciones
            audit_results['recommendations'] = self._generate_recommendations(audit_results)

            logger.info("‚úÖ Auditor√≠a completa finalizada")

        except Exception as e:
            logger.error(f"‚ùå Error durante la auditor√≠a: {e}")
            audit_results['error'] = str(e)

        finally:
            # Cerrar conexi√≥n si es necesario
            pass

        return audit_results

    def _calculate_data_quality_score(self, data_quality_results: Dict) -> float:
        """Calcula un puntaje general de calidad de datos (0-100)"""
        if not data_quality_results:
            return 0.0

        scores = []
        for result in data_quality_results.values():
            if result['samples_collected'] > 0:
                # Puntaje basado en completitud y anomal√≠as
                completeness_score = result['data_completeness'] * 100
                anomaly_penalty = (result['price_anomalies'] + result['volume_anomalies']) * 5
                timestamp_penalty = result['timestamp_issues'] * 2

                score = max(0, completeness_score - anomaly_penalty - timestamp_penalty)
                scores.append(score)

        return np.mean(scores) if scores else 0.0

    def _generate_recommendations(self, audit_results: Dict) -> List[str]:
        """Genera recomendaciones basadas en los resultados de la auditor√≠a"""
        recommendations = []

        # Verificar modo p√∫blico
        active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
        if audit_results.get('audit_info', {}).get('public_mode', False):
            if active_exchange == 'BYBIT':
                recommendations.append("‚ÑπÔ∏è Modo p√∫blico: Configurar credenciales BYBIT_API_KEY y BYBIT_API_SECRET para pruebas completas")
            else:
                recommendations.append("‚ÑπÔ∏è Modo p√∫blico: Configurar credenciales BINANCE_TEST_API_KEY y BINANCE_TEST_API_SECRET para pruebas completas")

        # Verificar conexi√≥n
        if audit_results.get('connection_test', {}).get('status') != 'SUCCESS':
            recommendations.append(f"‚ùå CR√çTICO: Verificar configuraci√≥n de conexi√≥n a {active_exchange} Testnet")
            return recommendations

        # Verificar latencia
        latency_tests = audit_results.get('latency_tests', {})
        avg_latencies = [test.get('avg_latency_ms', 0) for test in latency_tests.values()]

        if avg_latencies and np.mean(avg_latencies) > 1000:  # > 1 segundo
            recommendations.append("‚ö†Ô∏è Alto: Latencia de API elevada (>1000ms). Considerar optimizaciones")

        # Verificar calidad de datos
        data_quality = audit_results.get('data_quality', {})
        quality_score = audit_results.get('overall_metrics', {}).get('data_quality_score', 0)

        if quality_score < 70:
            recommendations.append(f"‚ö†Ô∏è Calidad de datos baja ({quality_score:.1f}/100). Revisar integridad de datos")

        # Anomal√≠as espec√≠ficas
        total_anomalies = audit_results.get('overall_metrics', {}).get('price_anomalies_detected', 0)
        if total_anomalies > 0:
            recommendations.append(f"‚ö†Ô∏è Detectadas {total_anomalies} anomal√≠as de precio. Revisar l√≥gica de validaci√≥n")

        # Recomendaciones positivas
        if quality_score >= 90:
            recommendations.append("‚úÖ Excelente calidad de datos. Sistema funcionando correctamente")

        if avg_latencies and np.mean(avg_latencies) < 500:
            recommendations.append("‚úÖ Buena latencia de API (<500ms). Conexi√≥n √≥ptima")

        return recommendations

    def save_audit_report(self, audit_results: Dict, output_path: str = None):
        """
        Guarda el reporte de auditor√≠a en formato JSON.

        Args:
            audit_results: Resultados de la auditor√≠a
            output_path: Ruta donde guardar el reporte
        """
        if output_path is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = f"auditorias/audit_binance_testnet_{timestamp}.json"

        # Crear directorio si no existe
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(audit_results, f, indent=2, ensure_ascii=False, default=str)

            logger.info(f"‚úÖ Reporte de auditor√≠a guardado en: {output_path}")

        except Exception as e:
            logger.error(f"‚ùå Error guardando reporte: {e}")

    def print_audit_summary(self, audit_results: Dict):
        """Imprime un resumen de la auditor√≠a en consola"""
        active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
        print("\n" + "="*80)
        print(f"üìä REPORTE DE AUDITOR√çA - {active_exchange} TESTNET")
        print("="*80)

        # Informaci√≥n general
        audit_info = audit_results.get('audit_info', {})
        print(f"üïê Fecha: {audit_info.get('start_time', 'N/A')}")
        print(f"üéØ Testnet: {audit_info.get('testnet', False)}")
        print(f"üìà S√≠mbolos auditados: {', '.join(audit_info.get('symbols_tested', []))}")
        print(f"‚è±Ô∏è Duraci√≥n: {audit_info.get('duration_minutes', 0)} minutos")

        # Estado de conexi√≥n
        conn_test = audit_results.get('connection_test', {})
        status = conn_test.get('status', 'UNKNOWN')
        status_icon = "‚úÖ" if status == 'SUCCESS' else "‚ùå"
        print(f"\nüîó Conexi√≥n: {status_icon} {status}")

        # M√©tricas generales
        metrics = audit_results.get('overall_metrics', {})
        print("\nüìä M√âTRICAS GENERALES:")
        print(f"   ‚Ä¢ Total de solicitudes: {metrics.get('total_requests', 0)}")
        print(f"   ‚Ä¢ Solicitudes exitosas: {metrics.get('successful_requests', 0)}")
        print(f"   ‚Ä¢ Tasa de √©xito: {metrics.get('success_rate', 0):.2f}%")
        # Calidad de datos
        data_quality = audit_results.get('data_quality', {})
        if data_quality:
            print("\nüîç CALIDAD DE DATOS:")
            for key, quality in data_quality.items():
                completeness = quality.get('data_quality_score', quality.get('data_completeness', 0)) * 100
                anomalies = quality.get('price_anomalies', 0) + quality.get('volume_anomalies', 0)
                print(f"   ‚Ä¢ {key}: Completitud {completeness:.1f}%, Anomal√≠as: {anomalies}")
        # Latencia
        latency_tests = audit_results.get('latency_tests', {})
        if latency_tests:
            print("\n‚è±Ô∏è LATENCIA DE API:")
            for symbol, latency in latency_tests.items():
                avg_lat = latency.get('avg_latency_ms', 0)
                success_rate = latency.get('success_rate', 0) * 100
                print(f"   ‚Ä¢ {symbol}: {avg_lat:.1f}ms, √âxito: {success_rate:.1f}%")

        # Operaciones de trading
        trading_ops = audit_results.get('trading_operations', {})
        if trading_ops and trading_ops.get('status') != 'SKIPPED':
            print("\nüíº OPERACIONES DE TRADING:")
            trading_score = trading_ops.get('overall_trading_score', 0)
            print(f"   ‚Ä¢ Puntuaci√≥n general: {trading_score:.1f}%")

            # Balance
            balance = trading_ops.get('balance_check', {})
            if balance:
                print(f"   ‚Ä¢ Balance USDT: {balance.get('usdt_free', 0):.2f}")
                print(f"   ‚Ä¢ Balance BTC: {balance.get('btc_free', 0):.6f}")

            # √ìrdenes
            operations = ['market_buy_order', 'market_sell_order', 'limit_buy_order', 'oco_order', 'order_cancellation']
            for op_name in operations:
                op = trading_ops.get(op_name, {})
                if op and op.get('status') == 'SUCCESS':
                    print(f"   ‚Ä¢ {op_name.replace('_', ' ').title()}: ‚úÖ")
                elif op and op.get('status') == 'FAILED':
                    print(f"   ‚Ä¢ {op_name.replace('_', ' ').title()}: ‚ùå {op.get('error', '')}")
                elif op and op.get('status') == 'SKIPPED':
                    print(f"   ‚Ä¢ {op_name.replace('_', ' ').title()}: ‚è≠Ô∏è {op.get('reason', '')}")

        elif trading_ops.get('status') == 'SKIPPED':
            print("\nüíº OPERACIONES DE TRADING:")
            print(f"   ‚Ä¢ Estado: ‚è≠Ô∏è {trading_ops.get('reason', 'Modo p√∫blico')}")

        # Recomendaciones
        recommendations = audit_results.get('recommendations', [])
        if recommendations:
            print("\nüí° RECOMENDACIONES:")
            for rec in recommendations:
                print(f"   {rec}")

        print("\n" + "="*80)

async def main():
    """Funci√≥n principal"""
    active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
    print(f"üî¨ AUDITOR√çA DE DATOS LIVE - {active_exchange} TESTNET")
    print("=" * 60)

    try:
        # Crear auditor
        auditor = ExchangeTestnetAuditor()

        # Ejecutar auditor√≠a completa
        print("üöÄ Ejecutando auditor√≠a completa...")
        audit_results = await auditor.run_comprehensive_audit()

        # Imprimir resumen
        auditor.print_audit_summary(audit_results)

        # Guardar reporte
        auditor.save_audit_report(audit_results)

        print("‚úÖ Auditor√≠a completada exitosamente")

    except Exception as e:
        logger.error(f"‚ùå Error en auditor√≠a: {e}")
        print(f"‚ùå Error: {e}")
        return 1

    return 0

    def display_results(self, audit_results: Dict):
        """
        Muestra los resultados de la auditor√≠a de forma formateada.

        Args:
            audit_results: Resultados de la auditor√≠a
        """
        active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
        print("\n" + "="*80)
        print(f"üìã RESULTADOS DE LA AUDITOR√çA - {active_exchange} TESTNET")
        print("="*80)

        # Informaci√≥n general
        audit_info = audit_results.get('audit_info', {})
        print(f"üïê Fecha: {audit_info.get('start_time', 'N/A')}")
        print(f"üéØ Testnet: {audit_info.get('testnet', False)}")
        print(f"üîí Modo p√∫blico: {audit_info.get('public_mode', False)}")
        print(f"üìà S√≠mbolos auditados: {', '.join(audit_info.get('symbols_tested', []))}")
        print(f"‚è±Ô∏è Duraci√≥n: {audit_info.get('duration_minutes', 0)} minutos")

        # Estado de conexi√≥n
        conn_test = audit_results.get('connection_test', {})
        status = conn_test.get('status', 'UNKNOWN')
        status_icon = "‚úÖ" if status == 'SUCCESS' else "‚ùå"
        print(f"\nüîó Conexi√≥n: {status_icon} {status}")

        # M√©tricas generales
        metrics = audit_results.get('overall_metrics', {})
        print("\nüìä M√âTRICAS GENERALES:")
        print(f"   ‚Ä¢ Duraci√≥n total: {metrics.get('total_duration_seconds', 0):.1f} segundos")
        print(f"   ‚Ä¢ Latencia promedio: {metrics.get('avg_latency_ms', 0):.1f}ms")
        print(f"   ‚Ä¢ Anomal√≠as de precio detectadas: {metrics.get('price_anomalies_detected', 0)}")
        print(f"   ‚Ä¢ Anomal√≠as de volumen detectadas: {metrics.get('volume_anomalies_detected', 0)}")
        print(f"   ‚Ä¢ Puntaje calidad de datos: {metrics.get('data_quality_score', 0):.1f}/100")

        # Calidad de datos
        data_quality = audit_results.get('data_quality', {})
        if data_quality:
            print("\nüîç CALIDAD DE DATOS:")
            for key, quality in data_quality.items():
                completeness = quality.get('data_completeness', 0) * 100
                anomalies = quality.get('price_anomalies', 0) + quality.get('volume_anomalies', 0)
                samples = quality.get('samples_collected', 0)
                print(f"   ‚Ä¢ {key}: {samples} muestras, Completitud {completeness:.1f}%, Anomal√≠as: {anomalies}")

        # Latencia
        latency_tests = audit_results.get('latency_tests', {})
        if latency_tests:
            print("\n‚è±Ô∏è LATENCIA DE API:")
            for symbol, latency in latency_tests.items():
                avg_lat = latency.get('avg_latency_ms', 0)
                success_rate = latency.get('success_rate', 0) * 100
                min_lat = latency.get('min_latency_ms', 0)
                max_lat = latency.get('max_latency_ms', 0)
                print(f"   ‚Ä¢ {symbol}: {avg_lat:.1f}ms (min: {min_lat:.1f}ms, max: {max_lat:.1f}ms), √âxito: {success_rate:.1f}%")

        # Recomendaciones
        recommendations = audit_results.get('recommendations', [])
        if recommendations:
            print("\nüí° RECOMENDACIONES:")
            for rec in recommendations:
                print(f"   {rec}")

        print("\n" + "="*80)

def main():
    """Funci√≥n principal"""
    active_exchange = os.getenv('ACTIVE_EXCHANGE', 'binance').upper()
    print(f"üî¨ AUDITOR√çA DE DATOS LIVE - {active_exchange} TESTNET")
    print("=" * 60)

    try:
        # Crear auditor
        auditor = ExchangeTestnetAuditor()

        print("üöÄ Ejecutando auditor√≠a completa...")

        # Ejecutar auditor√≠a
        audit_results = auditor.run_comprehensive_audit()

        # Mostrar resultados (ya se hace en run_comprehensive_audit)
        # display_results(audit_results)

        print("\n‚úÖ Auditor√≠a completada exitosamente")
        return 0

    except Exception as e:
        logger.error(f"‚ùå Error: {e}")
        print(f"‚ùå Error: {e}")
        return 1

if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Auditor√≠a interrumpida por el usuario")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        sys.exit(1)
        